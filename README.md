# 프로젝트를 통한 기본 개념 정리
## 1. 스프링 프레임워크 특징 또는 장점
- 스프링 프레임워크란?
자바 엔터프라이즈 개발을 편하게 해주는 경량화된 솔루션
즉 대규모 데이터 처리와 트랜잭션이 동시에 여러 사용자로 부터 행해지는 매우 큰 규모의 환경을 개발합니다.
스프링 프레임워크는 객체의 생성과 소멸 그리고 라이프사이클을 관리하며 언제든지 스프링 컨테이너로 부터 팰요한 객체를 가져와 사용할 수 있다.

- 스프링은 IOC기반이다.
IOC는 Inversion of Control의 약자로 제어의 역전이다.
일반적으로 프로그램을 개발할 때, 객체의 결정 및 생성 -> 의존성 객체 생성 -> 객체 내 메소드 호출을 반복한다.
이는 개발자가 객체를 구성하고 직접적으로 참여한다. 즉 모든 작업을 제어하는 구조이다.

하지만 IOC는 이 흐름의 구조를 바꾼다. 자신이 어디서 만들어지고 어떻게 사용되는지 모른다. 자신의 모든 권한을 다른 대상에 위임한다.
제어권한을 위임받은 특별한 객체에 의해 결정되고 만들어진다.
즉, 제어의 흐름을 사용자가 컨트롤 하지 않고 위임한 특별한 객체에 모든 것을 맡기는 것이다.

## 2. DI를 사용하는 이유?
외부에서 두 객체 간 관계를 결정해주는 디자인 패턴으로 인터페이스를 사이로 클래스 레벨에서는 의존관계가 고정되지 않도록 하고 런타임 때 관계를 주입하여 유연성을 확보, 결합도를 낮추었다.

```java
public class MemberController {

  private MemberService memberService;

  public MemberController() {

    memberService = new MemberService();

  }
}
```

위 예제는 문제점을 가지고 있다.
- 두 클래스가 강하게 결합되어 있다.
- 객체들간의 관계가 아닌 클래스 간의 관계가 맺어지고 있다.
- 두 클래스가 강하게 결합되어 있다는 문제점은 만약 MemberService의 클래스가 아닌 다른 클래스를 사용해야 하는 요구사항이 주어지만 MemberController 클래스를 수정해야 한다. 즉 유연성이 떨어진다.
- 객체 간의 관계가 아니라 클래스 간의 관계가 맺어져 올바른 객체지향적 설계라고 할 수 없다.
- 객체들 간 관계가 맺어졌다면 다른 객체의 구체 클래스를 전혀 알지 못하더라도 인터페이스 타입으로 사용할 수 있다.

위 문제를 해결하기 위해 스프링에서는 
- DI컨테이너를 통해 서로 강하게 결합되어 있는 클래스들을 분리하고 객체 간의 관계를 결정하여 결합도를 낮추고 유연성을 확보한다.
- DI컨테이너는 각 클래스 사이에 필요로 하는 의존관계를 빈 설정 정보를 바탕으로 자동으로 연결해 준다.
- 의존성 주입의 장점으로는 컴파일시에 이루어지는 것이 아닌 실행시에 이루어져 모듈간의 결합도를 낮출 수 있고, 코드 재사용 높여준다.

의존성 주입 3가지
- 생성자 주입
생성자에서 받는 방식이다. 컨테이너가 알아서 생성자에 객체를 넣어주면서 생성하는 방식이다. 이 때 final로 설정하는 것이 좋다.
```java
public class MemberController {
  private final MemberRepository memberRepository;

  public MemberController(MemberRepository memberRepository) {
    this.memberRepository = memberRepository;
  }
}
```

- setter 주입
```java
setter 메소드를 통해 주입받는 방식이다.

public class MemberController {
  private MemberRepository memberRepository;

  public void setMemberRepository(MemberRepository memberRepository) {
    this.memberRepository = memberRepository;
  }
}
```

- 필드 주입
주입 받을 필드에 @Autowired 어노테이션을 붙여주면 컨테이너가 알아서 resolve 해준다.
```java
public class MemberController {
  @Autowired
  private MemberRepository memberRepository;
}
```

3. 스프링 시큐리티를 사용하여 회원관리하는 방법 순서도

4. 테스트 코드 작성 시 장단점과 테스트 종류별 특징
- 개발자 테스트
장점 
1. 빠르고 정확한 테스트 가능 (예상 동작 vs 실제 동작)
2. 테스트 자동화 가능(배포 절차 시 테스트 코드가 수행되어 동작 검증)
3. 리팩토링 후 기존 동작에 대한 보증수표

단점
1. 개발 시간이 오래걸림
2. 기존코드 작성하면 테스트 코드도 수정해야 해서 유지보수하는 비용 발생

- 단위 테스트
1. 하나의 모듈이나 클래스에 대해 세밀한 부분까지 테스트 가능
2. 모듈 간에 상호 작용 검증 못함

- 통합 테스트
1. 하나의 모듈이나 클래스에 대해 세밀한 부분까지 테스트 가능
2. 모듈 간에 상호 작용 검증 못함

- E2E 테스트 (End to End Test)
1. 실제 사용자의 실행 환경과 거의 동일한 환경에서 테스트 진행(= 블랙박스 테스팅)
2. 다양한 실사용자 테스트 환경에 맞춰 테스트하는 것이 어려움(다양한 단말기 환경)
3. 다양한 네트워크 환경

5. ORM, JPA, Spring Data JPA
## ORM(Object-Relation Mapping)
객체 관계 매핑, 객체지향적인 JAVA와 관계형 데이터베이스 테이블 간에 불일치가 존재한다.
ORM은 객체 관계를 바탕으로 SQL을 자동으로 생성하여 데이터베이스를 다룬다.

장점
1. 객체 지향적인 코드 작성으로 더 직관적이고, 비즈니스 로직에 더 집중할 수 있다.
- SQL 쿼리문이 아닌 직관적인 코드(객체)로 데이터를 조작할 수 있어 개발자가 객체 모델로 프로그래밍 하는데 더 집중 할 수 있도록 도와준다.
- 객체에 대한 코드로 별도로 작성하기 때문에 코드의 가독성을 올려준다.
- SQL의 절차적이고 순차적인 접근이 아닌 객체 지향적 접근으로 인해 생산성이 증가한다.

2. 재사용 및 유지보수의 편리성이 증가한다.
- ORM은 독립적으로 작성되어 있고 해당 객체들을 재활용할 수 있다.
- 모델에서 가공된 데이터(DTO)를 컨트롤러에 의해 뷰와 합쳐지는 형태로 디자인 패턴을 견고하게 다지는데 유리하다.
- 매핑정보가 명확하여, 개체-관계 모델을 보는 것에 대한 의존도를 낮출 수 있다.

3. DBMS 에 대한 종속성이 줄어든다.
- 객체 관계를 바탕으로 SQL을 자동으로 생성하기 때문에 RDBMS의 데이터 구조와와 JAVA 객체지향 모델간의 간격을 좁힐 수 있다.
- ORM 솔루션은 DB에 종속적이지 않다.
- 프로그래머는 객체에 집중함으로 극단적으로 DBMS를 교체하는 거대한 작업에도 비교적 적은 리스크와 시간이 소요된다.
- 자바에서 가공할 경우 equals, hashCode의 오버라이드 같은 자바와 기능을 이용할 수 있고, 간결하고 빠른 가공이 가능하다.

단점
1. 완벽하게 ORM으로만 서비스를 구현하기 어렵다.
- 사용하기에는 쉽지만 설계하는데에는 매우 신중해야한다.
- 프로젝트의 복잡성이 커질경우 난이도 또한 올라갈 수 있다.
- 잘못 구현된 경우에 속도 저하 및 일관성이 무너지는 문제점이 발생할 수 있다.

2. 잘못 구현된 경우에 속도 저하 및 일관성이 무너지는 문제점이 발생할 수 있다.
- 다시 객체로 바꿔야하며, 그 과정에서 생산성 저하나 리스크가 많이 발생 할 수 있다.

ORM 프레임워크 중에서 하이버네이트 프레임워크를 가장 많이 사용한다.

## JPA(Java Persistence API)
JPA(Java Persistance API)는 자바 진영의 ORM 기술 표준이다. 자바 진영에서 하이버네이트라는 오픈소스 ORM 프레임워크를 기반으로 새로운 자바 ORM 기술표준을 만들었는데 그것이 JPA이다. JPA는 라이브러리가 아닌 자바 어플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스이다. 하이버네이트는 JPA의 구현체이다.

## Spring Data JPA
Spring 에서 JPA를 편리하게 쓰기 편하게 만들어놓은 모듈이다. JPA를 한 단계 더 추상화시킨 Repository라는 인터페이스를 제공함으로써 이루어진다.

- 공통 메서드가 아닐 경우에도 JPA가 메서드 이름을 분석하여 JPQL을 생성한다.
- 개발자는 repository에 인터페이스만 작성해도 개발을 완료할 수 있도록 지원해준다.
- Spring Data JPA가 구현 객체를 동적으로 생성하여 주입해준다.
- CRUD 처리를 위한 공통 인터페이스를 제공한다.
